diff --git a/arch/ia64/Kconfig b/arch/ia64/Kconfig
index efd4af4b930e..a1ea81711c5e 100644
--- a/arch/ia64/Kconfig
+++ b/arch/ia64/Kconfig
@@ -15,16 +15,16 @@ config IA64
 	select ARCH_HAS_STRNLEN_USER
 	select ARCH_MIGHT_HAVE_PC_PARPORT
 	select ARCH_MIGHT_HAVE_PC_SERIO
-	select ACPI
+	select ACPI if (!IA64_HP_SIM)
 	select ACPI_NUMA if NUMA
 	select ARCH_ENABLE_MEMORY_HOTPLUG
 	select ARCH_ENABLE_MEMORY_HOTREMOVE
-	select ARCH_SUPPORTS_ACPI
+	select ARCH_SUPPORTS_ACPI if (!IA64_HP_SIM)
 	select ACPI_SYSTEM_POWER_STATES_SUPPORT if ACPI
 	select ARCH_MIGHT_HAVE_ACPI_PDC if ACPI
-	select FORCE_PCI
+	select FORCE_PCI if (!IA64_HP_SIM)
 	select PCI_DOMAINS if PCI
-	select PCI_MSI
+	select PCI_MSI if PCI
 	select PCI_SYSCALL if PCI
 	select HAS_IOPORT
 	select HAVE_ASM_MODVERSIONS
@@ -55,7 +55,7 @@ config IA64
 	select ARCH_CLOCKSOURCE_DATA
 	select GENERIC_TIME_VSYSCALL
 	select LEGACY_TIMER_TICK
-	select SWIOTLB
+	select SWIOTLB if (!IA64_HP_SIM)
 	select SYSCTL_ARCH_UNALIGN_NO_WARN
 	select HAVE_MOD_ARCH_SPECIFIC
 	select MODULES_USE_ELF_RELA
@@ -119,6 +119,33 @@ config AUDIT_ARCH
 	bool
 	default y
 
+choice
+	prompt "System type"
+	default IA64_GENERIC
+
+config IA64_GENERIC
+	bool "generic"
+	select NUMA
+	select ACPI_NUMA
+	select SWIOTLB
+	select PCI_MSI
+	help
+	  This selects the system type of your hardware.  A "generic" kernel
+	  will run on any supported IA-64 system.  However, if you configure
+	  a kernel for your specific system, it will be faster and smaller.
+
+	  generic		For any supported IA-64 system, except Ski
+	  Ski-simulator		For the HP simulator <http://www.hpl.hp.com/research/linux/ski/>
+
+	  If you don't know what to do, choose "generic".
+
+config IA64_HP_SIM
+	bool "Ski-simulator"
+	select FLATMEM
+	#depends on !PM
+
+endchoice
+
 choice
 	prompt "Processor type"
 	default ITANIUM
@@ -171,7 +198,14 @@ config IA64_PAGE_SIZE_64KB
 
 endchoice
 
+if IA64_HP_SIM
+config HZ
+	default 32
+endif
+
+if !IA64_HP_SIM
 source "kernel/Kconfig.hz"
+endif
 
 config IA64_BRL_EMU
 	bool
@@ -205,6 +239,11 @@ config IA64_CYCLONE
 	  Say Y here to enable support for IBM EXA Cyclone time source.
 	  If you're unsure, answer N.
 
+config IOSAPIC
+	bool
+	depends on !IA64_HP_SIM
+	default y
+
 config ARCH_FORCE_MAX_ORDER
 	int
 	default "16" if HUGETLB_PAGE
@@ -283,6 +322,7 @@ config ARCH_FLATMEM_ENABLE
 	def_bool y
 
 config ARCH_SPARSEMEM_ENABLE
+	depends on !IA64_HP_SIM
 	def_bool y
 	select SPARSEMEM_VMEMMAP_ENABLE
 
@@ -366,10 +406,10 @@ config IA64_HP_AML_NFW
 endmenu
 
 config ARCH_SUPPORTS_KEXEC
-	def_bool !SMP || HOTPLUG_CPU
+	def_bool !IA64_HP_SIM && (!SMP || HOTPLUG_CPU)
 
 config ARCH_SUPPORTS_CRASH_DUMP
-	def_bool IA64_MCA_RECOVERY && (!SMP || HOTPLUG_CPU)
+	def_bool IA64_MCA_RECOVERY && !IA64_HP_SIM && (!SMP || HOTPLUG_CPU)
 
 menu "Power management and ACPI options"
 
@@ -385,6 +425,8 @@ endif
 
 endmenu
 
+source "arch/ia64/hp/sim/Kconfig"
+
 config MSPEC
 	tristate "Memory special operations driver"
 	depends on IA64
diff --git a/arch/ia64/Makefile b/arch/ia64/Makefile
index d553ab7022fe..bf0d35e59dea 100644
--- a/arch/ia64/Makefile
+++ b/arch/ia64/Makefile
@@ -47,7 +47,8 @@ KBUILD_CFLAGS += $(cflags-y)
 
 libs-y				+= arch/ia64/lib/
 
-drivers-y			+= arch/ia64/pci/ arch/ia64/hp/common/
+drivers-$(CONFIG_IA64_HP_SIM)	+= arch/ia64/hp/sim/
+drivers-$(CONFIG_IA64_GENERIC)	+= arch/ia64/pci/ arch/ia64/hp/common/
 
 PHONY += compressed check
 
diff --git a/arch/ia64/include/asm/acpi.h b/arch/ia64/include/asm/acpi.h
index 58500a964238..3b0a148a04d3 100644
--- a/arch/ia64/include/asm/acpi.h
+++ b/arch/ia64/include/asm/acpi.h
@@ -17,7 +17,7 @@
 #include <linux/numa.h>
 #include <asm/numa.h>
 
-
+#ifdef	CONFIG_ACPI
 extern int acpi_lapic;
 #define acpi_disabled 0	/* ACPI always enabled on IA64 */
 #define acpi_noirq 0	/* ACPI always enabled on IA64 */
@@ -28,7 +28,7 @@ static inline bool acpi_has_cpu_in_madt(void)
 {
 	return !!acpi_lapic;
 }
-
+#endif
 #define acpi_processor_cstate_check(x) (x) /* no idle limits on IA64 :) */
 static inline void disable_acpi(void) { }
 
diff --git a/arch/ia64/include/asm/iosapic.h b/arch/ia64/include/asm/iosapic.h
index a91aeb413e17..49d5083a2c6c 100644
--- a/arch/ia64/include/asm/iosapic.h
+++ b/arch/ia64/include/asm/iosapic.h
@@ -52,12 +52,14 @@
 
 #ifndef __ASSEMBLY__
 
-#define NR_IOSAPICS			256
+#ifdef CONFIG_IOSAPIC
 
-#define iosapic_pcat_compat_init	ia64_native_iosapic_pcat_compat_init
-#define __iosapic_read			__ia64_native_iosapic_read
-#define __iosapic_write			__ia64_native_iosapic_write
-#define iosapic_get_irq_chip		ia64_native_iosapic_get_irq_chip
+# define NR_IOSAPICS			256
+
+# define iosapic_pcat_compat_init	ia64_native_iosapic_pcat_compat_init
+# define __iosapic_read			__ia64_native_iosapic_read
+# define __iosapic_write			__ia64_native_iosapic_write
+# define iosapic_get_irq_chip		ia64_native_iosapic_get_irq_chip
 
 extern void __init ia64_native_iosapic_pcat_compat_init(void);
 extern struct irq_chip *ia64_native_iosapic_get_irq_chip(unsigned long trigger);
@@ -98,9 +100,19 @@ extern int __init iosapic_register_platform_intr (u32 int_type,
 					   unsigned long polarity,
 					   unsigned long trigger);
 
-#ifdef CONFIG_NUMA
+# ifdef CONFIG_NUMA
 extern void map_iosapic_to_node (unsigned int, int);
-#endif
+# endif
+#else /* CONFIG_IOSAPIC */
+# define iosapic_system_init(pcat_compat)			do { } while (0)
+# define iosapic_init(address,gsi_base)				(-EINVAL)
+# define iosapic_remove(gsi_base)				(-ENODEV)
+# define iosapic_register_intr(gsi,polarity,trigger)		(gsi)
+# define iosapic_unregister_intr(irq)				do { } while (0)
+# define iosapic_override_isa_irq(isa_irq,gsi,polarity,trigger)	do { } while (0)
+# define iosapic_register_platform_intr(type,gsi,pmi,eid,id, \
+	polarity,trigger)					(gsi)
+#endif /* CONFIG_IOSAPIC */
 
 # endif /* !__ASSEMBLY__ */
 #endif /* __ASM_IA64_IOSAPIC_H */
diff --git a/arch/ia64/kernel/Makefile b/arch/ia64/kernel/Makefile
index d7e1cabee2ec..24392141d33e 100644
--- a/arch/ia64/kernel/Makefile
+++ b/arch/ia64/kernel/Makefile
@@ -12,12 +12,13 @@ extra-y	:= vmlinux.lds
 obj-y := head.o entry.o efi.o efi_stub.o gate-data.o fsys.o irq.o irq_ia64.o	\
 	 irq_lsapic.o ivt.o pal.o patch.o process.o ptrace.o sal.o		\
 	 salinfo.o setup.o signal.o sys_ia64.o time.o traps.o unaligned.o \
-	 unwind.o mca.o mca_asm.o topology.o dma-mapping.o iosapic.o acpi.o \
-	 acpi-ext.o
+	 unwind.o mca.o mca_asm.o topology.o dma-mapping.o
 
+obj-$(CONFIG_ACPI)		+= acpi.o acpi-ext.o
 obj-$(CONFIG_IA64_BRL_EMU)	+= brl_emu.o
 
 obj-$(CONFIG_IA64_PALINFO)	+= palinfo.o
+obj-$(CONFIG_IOSAPIC)		+= iosapic.o
 obj-$(CONFIG_MODULES)		+= module.o
 obj-$(CONFIG_SMP)		+= smp.o smpboot.o
 obj-$(CONFIG_NUMA)		+= numa.o
@@ -29,7 +30,7 @@ obj-$(CONFIG_KEXEC)		+= machine_kexec.o relocate_kernel.o crash.o
 obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
 obj-$(CONFIG_IA64_UNCACHED_ALLOCATOR)	+= uncached.o
 obj-$(CONFIG_AUDIT)		+= audit.o
-obj-y				+= msi_ia64.o
+obj-$(CONFIG_PCI_MSI)		+= msi_ia64.o
 mca_recovery-y			+= mca_drv.o mca_drv_asm.o
 obj-$(CONFIG_IA64_MC_ERR_INJECT)+= err_inject.o
 obj-$(CONFIG_STACKTRACE)	+= stacktrace.o
diff --git a/arch/ia64/kernel/irq_ia64.c b/arch/ia64/kernel/irq_ia64.c
index 46e33c5cb53d..c99026623221 100644
--- a/arch/ia64/kernel/irq_ia64.c
+++ b/arch/ia64/kernel/irq_ia64.c
@@ -40,6 +40,10 @@
 #include <asm/hw_irq.h>
 #include <asm/tlbflush.h>
 
+#ifdef CONFIG_IA64_HP_SIM
+#include <asm/hpsim.h>
+#endif
+
 #define IRQ_DEBUG	0
 
 #define IRQ_VECTOR_UNASSIGNED	(0)
@@ -244,7 +248,7 @@ void __setup_vector_irq(int cpu)
 	}
 }
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && defined(CONFIG_IA64_GENERIC)
 
 static enum vector_domain_type {
 	VECTOR_DOMAIN_NONE,
@@ -358,12 +362,12 @@ static int __init parse_vector_domain(char *arg)
 	return 0;
 }
 early_param("vector", parse_vector_domain);
-#else
+#else /* defined(CONFIG_SMP) && defined(CONFIG_IA64_GENERIC) */
 static cpumask_t vector_allocation_domain(int cpu)
 {
 	return CPU_MASK_ALL;
 }
-#endif
+#endif /* defined(CONFIG_SMP) && defined(CONFIG_IA64_GENERIC) */
 
 
 void destroy_and_reserve_irq(unsigned int irq)
@@ -613,15 +617,22 @@ ia64_native_register_ipi(void)
 void __init
 init_IRQ (void)
 {
+#ifdef CONFIG_ACPI
 	acpi_boot_init();
+#endif
 	ia64_register_ipi();
 	register_percpu_irq(IA64_SPURIOUS_INT_VECTOR, NULL, 0, NULL);
 #ifdef CONFIG_SMP
+# if defined(CONFIG_IA64_GENERIC)
 	if (vector_domain_type != VECTOR_DOMAIN_NONE) {
 		register_percpu_irq(IA64_IRQ_MOVE_VECTOR,
 				    smp_irq_move_cleanup_interrupt, 0,
 				    "irq_move");
 	}
+# endif
+#endif
+#ifdef CONFIG_IA64_HP_SIM
+	hpsim_irq_init();
 #endif
 }
 
diff --git a/arch/ia64/kernel/mca.c b/arch/ia64/kernel/mca.c
index 2671688d349a..4c6f1e055814 100644
--- a/arch/ia64/kernel/mca.c
+++ b/arch/ia64/kernel/mca.c
@@ -151,7 +151,9 @@ static ia64_mc_info_t		ia64_mc_info;
 #define CPE_HISTORY_LENGTH    5
 #define CMC_HISTORY_LENGTH    5
 
+#ifdef CONFIG_ACPI
 static struct timer_list cpe_poll_timer;
+#endif
 static struct timer_list cmc_poll_timer;
 /*
  * This variable tells whether we are currently in polling mode.
@@ -531,6 +533,8 @@ int mca_recover_range(unsigned long addr)
 }
 EXPORT_SYMBOL_GPL(mca_recover_range);
 
+#ifdef CONFIG_ACPI
+
 int cpe_vector = -1;
 int ia64_cpe_irq = -1;
 
@@ -592,6 +596,9 @@ ia64_mca_cpe_int_handler (int cpe_irq, void *arg)
 	return IRQ_HANDLED;
 }
 
+#endif /* CONFIG_ACPI */
+
+#ifdef CONFIG_ACPI
 /*
  * ia64_mca_register_cpev
  *
@@ -619,6 +626,7 @@ ia64_mca_register_cpev (int cpev)
 	IA64_MCA_DEBUG("%s: corrected platform error "
 		       "vector %#x registered\n", __func__, cpev);
 }
+#endif /* CONFIG_ACPI */
 
 /*
  * ia64_mca_cmc_vector_setup
@@ -1533,6 +1541,8 @@ ia64_mca_cmc_poll (struct timer_list *unused)
  * Outputs
  * 	handled
  */
+#ifdef CONFIG_ACPI
+
 static irqreturn_t
 ia64_mca_cpe_int_caller(int cpe_irq, void *arg)
 {
@@ -1595,6 +1605,8 @@ ia64_mca_cpe_poll (struct timer_list *unused)
 							IA64_IPI_DM_INT, 0);
 }
 
+#endif /* CONFIG_ACPI */
+
 static int
 default_monarch_init_process(struct notifier_block *self, unsigned long val, void *data)
 {
@@ -2042,9 +2054,11 @@ void __init ia64_mca_irq_init(void)
 	register_percpu_irq(IA64_MCA_WAKEUP_VECTOR, ia64_mca_wakeup_int_handler,
 			    0, "mca_wkup");
 
+#ifdef CONFIG_ACPI
 	/* Setup the CPEI/P handler */
 	register_percpu_irq(IA64_CPEP_VECTOR, ia64_mca_cpe_int_caller, 0,
 			    "cpe_poll");
+#endif
 }
 
 /*
@@ -2072,6 +2086,7 @@ ia64_mca_late_init(void)
 			  ia64_mca_cpu_online, NULL);
 	IA64_MCA_DEBUG("%s: CMCI/P setup and enabled.\n", __func__);
 
+#ifdef CONFIG_ACPI
 	/* Setup the CPEI/P vector and handler */
 	cpe_vector = acpi_request_vector(ACPI_INTERRUPT_CPEI);
 	timer_setup(&cpe_poll_timer, ia64_mca_cpe_poll, 0);
@@ -2104,6 +2119,7 @@ ia64_mca_late_init(void)
 			IA64_MCA_DEBUG("%s: CPEP setup and enabled.\n", __func__);
 		}
 	}
+#endif
 
 	return 0;
 }
diff --git a/arch/ia64/kernel/setup.c b/arch/ia64/kernel/setup.c
index f6d6a3b5d1f0..123d9452d47f 100644
--- a/arch/ia64/kernel/setup.c
+++ b/arch/ia64/kernel/setup.c
@@ -67,6 +67,8 @@
 #include <asm/uv/uv.h>
 #include <asm/xtp.h>
 
+#include <asm/hpsim.h>
+
 #if defined(CONFIG_SMP) && (IA64_CPU_SIZE > PAGE_SIZE)
 # error "struct cpuinfo_ia64 too big!"
 #endif
@@ -489,11 +491,15 @@ io_port_init (void)
 static inline int __init
 early_console_setup (char *cmdline)
 {
+	int earlycons = 0;
 #ifdef CONFIG_EFI_PCDP
 	if (!efi_setup_pcdp_console(cmdline))
-		return 0;
+		earlycons++;
 #endif
-	return -1;
+	if (!simcons_register())
+		earlycons++;
+
+	return (earlycons) ? 0 : -1;
 }
 
 static void __init
@@ -564,20 +570,21 @@ setup_arch (char **cmdline_p)
 
 	if (early_console_setup(*cmdline_p) == 0)
 		mark_bsp_online();
-
+#ifdef CONFIG_ACPI
 	/* Initialize the ACPI boot-time table parser */
 	acpi_table_init();
 	early_acpi_boot_init();
-#ifdef CONFIG_ACPI_NUMA
+# ifdef CONFIG_ACPI_NUMA
 	acpi_numa_init();
 	acpi_numa_fixup();
-#ifdef CONFIG_ACPI_HOTPLUG_CPU
+#  ifdef CONFIG_ACPI_HOTPLUG_CPU
 	prefill_possible_map();
-#endif
+#  endif
 	per_cpu_scan_finalize((cpumask_empty(&early_cpu_possible_map) ?
 		32 : cpumask_weight(&early_cpu_possible_map)),
 		additional_cpus > 0 ? additional_cpus : 0);
-#endif /* CONFIG_ACPI_NUMA */
+# endif /* CONFIG_ACPI_NUMA */
+#endif /* CONFIG_APCI */
 
 #ifdef CONFIG_SMP
 	smp_build_cpu_map();
@@ -639,6 +646,9 @@ setup_arch (char **cmdline_p)
 #endif
 
 	screen_info_setup();
+#ifndef CONFIG_IA64_HP_SIM
+	check_sal_cache_flush();
+#endif
 	paging_init();
 
 	clear_sched_clock_stable();
diff --git a/arch/ia64/kernel/topology.c b/arch/ia64/kernel/topology.c
index 94a848b06f15..741863a187a6 100644
--- a/arch/ia64/kernel/topology.c
+++ b/arch/ia64/kernel/topology.c
@@ -59,7 +59,7 @@ void __ref arch_unregister_cpu(int num)
 }
 EXPORT_SYMBOL(arch_unregister_cpu);
 #else
-static int __init arch_register_cpu(int num)
+int __init arch_register_cpu(int num)
 {
 	return register_cpu(&sysfs_cpus[num].cpu, num);
 }
diff --git a/arch/ia64/mm/contig.c b/arch/ia64/mm/contig.c
index 1e9eaa107eb7..7e26cd17dbde 100644
--- a/arch/ia64/mm/contig.c
+++ b/arch/ia64/mm/contig.c
@@ -180,10 +180,12 @@ static void __init verify_gap_absence(void)
 
 	/* Forbid FLATMEM if hole is > than 1G */
 	efi_memmap_walk(find_largest_hole, (u64 *)&max_gap);
+	/*
 	if (max_gap >= SZ_1G)
 		panic("Cannot use FLATMEM with %ldMB hole\n"
 		      "Please switch over to SPARSEMEM\n",
 		      (max_gap >> 20));
+	*/
 }
 
 /*
